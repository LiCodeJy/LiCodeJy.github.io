# JVM

## 内存分配图

JDK1.8前

![image-20210323101002563](C:\Users\29189\AppData\Roaming\Typora\typora-user-images\image-20210323101002563.png)

JDK1.8后

![image-20210323101054155](C:\Users\29189\AppData\Roaming\Typora\typora-user-images\image-20210323101054155.png)



### 程序计数器

字节码解释器通过改变下一个计数器的值来选取下一条指令

线程切换时，记录当前线程执行的位置

### 虚拟机栈

以栈帧的形式存在，存储局部变量表，操作数栈，动态链接，方法出口信息

### 堆

存储对象实例和数组

也叫GC堆，分为新生代，老年代，永久代

### 方法区

存放已被虚拟机加载的类信息，常量，静态变量，即使编译后的代码

## java对象的创建

1. 类加载检查

2. 分配内存

   指针碰撞：针对内存规整的情况

   空闲列表：针对内存中空闲区域不连续，分散的情况

   多线程情况下分配内存

   - CAS+失败重试  乐观锁，先用CAS尝试，冲突就重试
   - TLAB  在eden区为每个线程先分配一片内存空间，用完后再用失败重试的方式获取

3. 初始化零值

4. 设置对象头

   对象头包括对象类型信息，GC信息，对象哈希值

5. 执行init()方法

### 对象的访问定位

直接指针

![image-20210323134759558](C:\Users\29189\AppData\Roaming\Typora\typora-user-images\image-20210323134759558.png)

句柄

![image-20210323134807888](C:\Users\29189\AppData\Roaming\Typora\typora-user-images\image-20210323134807888.png)

## JVM垃圾回收

### 分配与回收基础

对象一般先在eden区分配，当eden区没有足够空间的时候，发起minorGC，如果eden空间还是不够分配下一个对象，则通过**分配担保机制**将对象存入老年代中，如果老年代空间也不足，则触发fullGC

大对象直接进入老年代，防止因为分配担保机制的复制而降低效率

### 如何判断对象死亡

- 引用计数法
- 可达性分析

### 垃圾收集算法

- 标记-清除  标记不需要回收的对象，标记完成后，直接回收（存在碎片）
- 标记-整理  将所有有用对象向一端移动，直接清理掉端边界外的（无碎片）
- 标记-复制  将内存分为相同大小的两块，需要清理时将有用的对象复制到空的那块（无碎片）
- 分代收集   针对不同周期的GC采用不同的策略，如新生代可采用标记复制，老年代没有多余空间分配担保，使用标记清除或标记复制

### 垃圾收集器

- serial收集器 单线程，新生代采用标记-复制，老年代采用标记-整理

- parNew收集器 serial收集器的多线程版本

- Parallel Scavenge 更关注吞吐量  新生代采用标记-复制算法，老年代采用标记-整理算法

- **CMS**收集器

  有四个阶段：初始标记 并发标记 重新标记 并发清除

- **G1收集器**

  初始标记 并发标记 最终标记 筛选回收

  G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region

### 双亲委派模型

